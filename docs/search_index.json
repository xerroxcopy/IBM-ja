[["バイアスのない変異とバイアスのある変異unbiased-and-biased-mutation.html", "Chapter 1 バイアスのない変異とバイアスのある変異Unbiased and biased mutation 1.1 バイアスのない変異Unbiased mutation 1.2 Biased mutation 1.3 モデルのまとめ 1.4 練習問題 1.5 もっと深く知りたい人に", " Chapter 1 バイアスのない変異とバイアスのある変異Unbiased and biased mutation 淘汰や浮動といった進化的プロセスは、新たな変異を生み出す源なしには成り立たない。遺伝子進化において、変異はほぼつねに変異が引き起こす機能と無関係に、盲目に発生する。有益な遺伝的変異が無益な遺伝的変異よりも起きやすいということはない。というか、実際にはほとんどの遺伝的変異は生物にとって中立か有害である。文化進化には新奇の変異が特定の問題を解決するよう方向づけされていたり、我々の認知の特徴によってシステマティックにバイアスがかかっている場合があるという興味深い特徴がある。以下で取り扱うモデルでは、バイアスのない変異とバイアスのある変異両方をシミュレートしてみたい。 1.1 バイアスのない変異Unbiased mutation まず、バイアスのない変異を前章で構築した基本的なモデルをもとにシミュレートする。バイアスのない伝達の過程を取り除き、バイアスのない変異の影響だけを観察できるようにする。 いままでのモデルと同様、人数\\(population\\_size\\)の個人がそれぞれ、ふたつの独立した文化的形質\\(A\\)か\\(B\\)を有しているとしよう。\\(generation = 1\\)から\\(generation = generations\\)までの各世代において、人数\\(population\\_size\\)の個人は同じく人数\\(population\\_size\\)の新しい個人に入れ替えられる。ただし今回は個々人がランダムに誰かから形質をコピーするのではなく、新しい個人は一つ前の世代の文化的形質をそのままコピーする。これは次のような状況とも考えられる。つまり、年数のようなタイムステップとしても捉えられる。\\(population\\_size\\)人の個人がちょうど\\(generations\\)年間生き、そのあいだ、毎年同じ文化的形質を有し続けるのだ。 しかし、各世代において個々人は\\(mutation\\_rate\\)1の確率で今の形質からもうひとつの形質に持ち替える。たとえば、ベジタリアンの個人が動物性の食品を食べ始めたり、その逆だったり、という具合だ。ここで気をつけてほしいのは、これらは（これまでのモデルのように）他の個人からコピーされるのではなく、個々人による意思決定による産物のたぐいであることだ。こうも考えられる。形質を持ち替える確率は各個人に独立して作用し、個人が変異するかどうかは他に何人変異した人がいるかになんの影響も受けない。平均して、各世代\\(mutation\\_rate \\times population\\_size\\)人の個人が変異することになる。以前のモデルと同様、\\(A\\)を有する個人の割合\\(proportion\\_of\\_trait\\_a\\)の推移に興味がある。 model_unbiased_mutation()という関数でラップしよう。ほとんどのコードはmodel_unbiased_transmissions_varying_initial_condition()からの流用だ。以前と同様、tibbleコマンドやggplot2などを使うためにtidyverseライブラリを読み込む。 library(tidyverse) model_unbiased_mutation &lt;- function( population_size, generations, runs, initial_proportion_of_trait_a, mutation_rate) { output &lt;- tibble( run = factor(), generation = numeric(), proportion_of_trait_a = numeric() ) for (run in 1:runs) { # 1回の試行の結果を保管するtibbleを初期化 output_single_run &lt;- tibble( run = rep(run, generations) |&gt; as.factor(), generation = 1:generations, proportion_of_trait_a = rep(NA, generations) ) # 第1世代 population &lt;- sample( c(&quot;A&quot;, &quot;B&quot;), population_size, replace = TRUE, prob = c(initial_proportion_of_trait_a, 1 - initial_proportion_of_trait_a) ) # 第1世代のproportion_of_trait_aを計算 proportion_of_trait_a &lt;- sum(population == &quot;A&quot;) / population_size output_single_run$proportion_of_trait_a[1] &lt;- proportion_of_trait_a for (generation in 2:generations) { # 前タイムステップまでのpopulationベクトルをprevious_populationに移し替える previous_population &lt;- population # 変異する個人(&#39;mutant&#39;)を決める is_mutant &lt;- sample( c(TRUE, FALSE), population_size, prob = c(mutation_rate, 1 - mutation_rate), replace = TRUE ) # is_mutantがTRUEであるスロットの形質がもしAならBに、もしBならAにする population[is_mutant] &lt;- population[is_mutant] |&gt; recode(A = &quot;B&quot;, B = &quot;A&quot;) # proportion_of_trait_aを計算し、tibbleのうち # proportion_of_trait_a列のgeneration行目に格納する output_single_run$proportion_of_trait_a[generation] &lt;- sum(population == &quot;A&quot;) / population_size } # output tibbleの一番下に今回の試行の結果をbind_rows()関数で付け加える output &lt;- bind_rows(output, output_single_run) } # 全試行の結果がひとつのoutputというtibbleに集約されたので、それを返り値としてエクスポートする output } mutation_rateの追加が唯一の変更である。mutation_rateパラメータは変異確率を決めるもので、generationを更新していくforループ内で、ランダムコピーするコマンドをバイアスなしの変異に置き換えている。変更点をひとつずつみていこう。 バイアスなしの変異を実装する最もありがちな方法は（上記の例では採用していないが）、もう一重forループを追加することだろう。各個人を一人ひとり集会していき、そのたびにその個人の形質が変異すべきかどうかをmutation_rateを使って計算していくのだ。これでもまあ動くには動くのだが、Rはループ計算が遅いことで非常に悪名高い。Rプログラミングにおいては、可能な限り「ベクトル化」されたコードのほうがよりよいとされている。is_mutant &lt;- sample()で始まる行や、population &lt;-で始まる行で行っているのがその「ベクトル化」である。 まず、各個人の変異する確率を前もって計算しておく。またしてもsample()関数を使い、TRUE（変異体mutantとして選ばれたことに対応する）とFALSE（変異体でないこと、つまり前世代と同じ文化的形質を保持し続けることに対応する）から選ぶことをpopulation_size回繰り返してis_mutantというベクトルとして保管しておく。いままでと違い、今回のサンプリングは完全なランダムではない。TRUEを選ぶ確率、つまり変異する確率は変異確率\\(mutation\\_rate\\)と等しくし、またFALSEを選ぶ確率は\\(1 - mutation\\_rate\\)となるようにした。つぎのように考えるとわかりやすいだろう。各個人はゆがんだ（バイアスのある）コインを投げる2。表の出る確率は\\(mutation\\_rate\\)で、裏の出る確率は\\(1 - mutation\\_rate\\)だ。もし表が出たら、その個人は今持っている形質を持ち替えないといけない。 ここでis_mutantの命名について軽く触れておく3。これは、長さpopulation_sizeのTRUEかFALSEのみを含むベクトルだ。こういったTRUEとFALSEのboolean型の真偽値を保管する場合、is_の接頭語がふさわしい。今回の場合、「このスロットにいる個人は変異体mutantか？」という質問に対する「はい(TRUE)」と「いいえ(FALSE)」を保管するから、is_mutantという名前がわかりやすいだろう。 続くpopulation[is_mutant] &lt;-ではじまる行では変異体として選ばれた個人の形質を持ち替えさせている4。population[is_mutant]は変異体の変異前の形質のベクトルになるから、これに形質をひっくり返したベクトルを代入することで変異させることができる。\"A\"を\"B\"に、\"B\"を\"A\"にする方法は色々あるが、ここではtidyverseのrecode()関数を使ってrecode( &lt;古い形質&gt; = \"&lt;新しい形質&gt;\")というふうに書く。 結果をプロットするには、[前章][バイアスなしの伝達]のplot_multiple_runs()がそのまま使える。 コードを実行し、プロットしてみよう： model_unbiased_mutation( population_size = 100, generations = 200, runs = 5, initial_proportion_of_trait_a = 0.5, mutation_rate = 0.05) |&gt; plot_multiple_runs() Figure 1.1: バイアスのない変異下では形質の頻度0.5近辺で変動する バイアスのない変異はランダムな変動は生み出すものの全体の\\(A\\)の頻度は世代を通して変わらず\\(proportion\\_of\\_trait\\_a = 0.5\\)近辺である。\\(A\\)から\\(B\\)への変異が\\(B\\)から\\(A\\)への変異と同じくらい起こりうるため、全体に方向性のある傾向は生じないのである。 バイアスのない伝達では、小さな集団(たとえば\\(population\\_size = 100\\)程度)ではかなりの頻度でどちらかの形質が数世代のうちに消滅したことを覚えているだろうか。今回のモデルでは、\\(population\\_size = 100\\)でもどちらの形質もシミュレーションの最後まで生き残っている。この差は何故生まれるのか？こう考えることができる。どちらかの形質が人気になり、たとえば\\(A\\)の頻度が\\(0.8\\)に達したとしよう。バイアスのない伝達においては、新しい世代の個々人は\\(A\\)をランダムに選び取る確率がかなり高くなる。形質\\(B\\)を有する少数派の個人は、80%の確率で\\(A\\)に持ち替える可能性があるためだ。他方、バイアスのない変異においては\\(mutation\\_rate\\)が個々人に独立に働くため、\\(A\\)の頻度が\\(0.8\\)である状況下5では、\\(B\\)に鞍替えする個人（具体的には\\(mutation\\_rate \\times proportion\\_of\\_trait\\_a \\times population\\_size\\)人、上記のセッティングでは4人）は\\(A\\)に鞍替えする個人（具体的には\\(mutation\\_rate \\times (1 - proportion\\_of\\_trait\\_a) \\times population\\_size\\)人、上記のセッティングでは1人）よりも多くなり、形質の頻度は\\(A\\)も\\(B\\)も同じくらいになるようにバランスされることになる。 しかし、異なる\\(A\\)と\\(B\\)の頻度で開始したらどうなるのだろう？たとえば、\\(proportion\\_of\\_trait\\_a = 0.1\\)とか\\(proportion\\_of_\\trait\\_a = 0.9\\)であったら？\\(A\\)は消えてしまうのだろうか？バイアスのない変異は、バイアスのない伝達であるModel 1でみたように、\\(proportion\\_of\\_trait\\_a\\)を初期値近辺で維持するのか？ 検証するため、\\(initial\\_proportion\\_of\\_trait\\_a\\)を変えて第1世代の個人が\\(B\\)よりも\\(A\\)を引く確率を下げてみよう。 model_unbiased_mutation( population_size = 100, generations = 200, runs = 5, initial_proportion_of_trait_a = 0.1, mutation_rate = 0.05) |&gt; plot_multiple_runs() Figure 1.2: バイアスのない変異は初期頻度に関係なく形質頻度を0.5に収束させる \\(proportion\\_of\\_trait\\_a\\)が\\(0.1\\)から\\(0.5\\)まで上昇しているはずだ。じつは、\\(A\\)と\\(B\\)の開始時の頻度がなんであろうと、前述した理由によってバイアスのない変異は\\(proportion\\_of\\_trait\\_a = 0.5\\)に導く。バイアスのない変異はつねに\\(A\\)と\\(B\\)のバランスを保つようにはたらく。 1.2 Biased mutation より興味深いバイアスのある変異にうつろう。確率\\(mutation\\_rate\\_biased\\)6で個人が形質\\(B\\)から\\(A\\)に持ち替えるが、形質\\(A\\)を持っている個人は形質\\(B\\)に持ち替える可能性がゼロだとしよう。形質\\(A\\)はたとえばとくべつキャッチーで覚えやすい話だったり現象の直感的な説明だと考えられる。そして\\(B\\)は覚えにくく、非直感的な理解を要求する。 以下の関数model_biased_mutation()はこの一方向性の変異をとらえている。 model_biased_mutation &lt;- function( population_size, generations, runs, initial_proportion_of_trait_a, mutation_rate_biased) { output &lt;- tibble( run = factor(), generation = numeric(), proportion_of_trait_a = numeric() ) for (run in 1:runs) { # 1回の試行の結果を保管するtibbleを初期化 output_single_run &lt;- tibble( run = rep(run, generations) |&gt; as.factor(), generation = 1:generations, proportion_of_trait_a = rep(NA, generations) ) # 第1世代 population &lt;- sample( c(&quot;A&quot;, &quot;B&quot;), population_size, replace = TRUE, prob = c(initial_proportion_of_trait_a, 1 - initial_proportion_of_trait_a) ) # 第1世代のproportion_of_trait_aを計算 proportion_of_trait_a &lt;- sum(population == &quot;A&quot;) / population_size output_single_run$proportion_of_trait_a[1] &lt;- proportion_of_trait_a for (generation in 2:generations) { # 前タイムステップまでのpopulationベクトルをprevious_populationに移し替える previous_population &lt;- population # 変異する個人(&#39;mutant&#39;)を決める is_mutant &lt;- sample( c(TRUE, FALSE), population_size, prob = c(mutation_rate_biased, 1 - mutation_rate_biased), replace = TRUE ) # is_mutantがTRUEであるスロットの形質をすべてAにする population[is_mutant] &lt;- &quot;A&quot; # proportion_of_trait_aを計算し、tibbleのうち # proportion_of_trait_a列のgeneration行目に格納する output_single_run$proportion_of_trait_a[generation] &lt;- sum(population == &quot;A&quot;) / population_size } # output tibbleの一番下に今回の試行の結果をbind_rows()関数で付け加える output &lt;- bind_rows(output, output_single_run) } # 全試行の結果がひとつのoutputというtibbleに集約されたので、それを返り値としてエクスポートする output } model_unbiased_mutation()からの変更は2点のみだ。まず、混同を避けるために mutation_rate を mutation_rate_biased とし、明確に別のパラメータとした。つぎに、model_unbiased_mutation()において\\(A\\)から\\(B\\)に形質が変化する処理がrecode()によって実装されていたが、それをなくし、すべて\"A\"を代入するようにした(population[is_mutant] &lt;- \"A\")7。 model_biased_mutation()を走らせて、効果をみよう。まず、全個人が\\(B\\)で構成されている集団、つまり\\(proportion\\_of\\_trait\\_a = 0\\)からはじめ、どれくらいのはやさで、またどのように\\(A\\)Aがバイアスのある変異によって拡散していくかをみる。 model_biased_mutation( population_size = 100, generations = 200, runs = 5, initial_proportion_of_trait_a = 0, mutation_rate_biased = 0.05) |&gt; plot_multiple_runs() Figure 1.3: バイアスのある変異によって有利な形質が不利な形質を置き換えていく プロットでは\\(proportion\\_of\\_trait\\_a\\)が急激に増え、それからゆっくりになり\\(generation = 100\\)近辺で\\(1\\)に達して平らになった（plateauに至った）。各試行である程度の変動はあるものの、そこまで大きくはないはずだ。もっと大きなサンプルサイズで試してみよう。 model_biased_mutation( population_size = 10000, generations = 200, runs = 5, initial_proportion_of_trait_a = 0, mutation_rate_biased = 0.05) |&gt; plot_multiple_runs() Figure 1.4: 集団サイズを大きくしても、バイアスのある変異が有利な形質の頻度を上昇させる速度は変わらない \\(population\\_size = 10000\\)では、試行間でほとんど変動はなく、なめらかな曲線になっているはずだ。しかし、前回とほぼ同じくらいの世代数、\\(generation = 100\\)近辺で平らになっていることに注意してほしい。集団サイズは新奇の形質がバイアスのある変異で拡散していく速さにほとんど全く影響を及ぼさない。他方、\\(mutation\\_rate\\_biased\\)の数値は速さに影響を与える。バイアスのある変異率を\\(0.1\\)に倍加してみよう。 model_biased_mutation( population_size = 10000, generations = 200, runs = 5, initial_proportion_of_trait_a = 0, mutation_rate_biased = 0.1) |&gt; plot_multiple_runs() Figure 1.5: Increasing the mutation rate increases the rate at which biased mutation causes the favoured trait to increase in frequency こちらでは\\(A\\)は\\(generation = 50\\)近辺で固定化する。\\(population\\_size\\)と\\(mutation\\_rate\\_biased\\)をいじってみて、後者が形質\\(A\\)の拡散・普及速度を決定することを確認し、また曲線がいつも同じような形、アルファベットの小文字rのような形で最初は急激な増加をしたあとに、\\(proportion\\_of\\_trait\\_a = 1\\)に近づくにつれ平らになる様子を確認しよう。 1.3 モデルのまとめ 今回の単純なモデルから、次のような洞察が導き出せる。無方向的であるという意味において遺伝的変異に類似するバイアスのない変異は、つねに2つの形質を同じくらいの割合にバランスさせる。バイアスのない変異は集団に文化的形質を持ち込み、それを維持する。バイアスのない変異とバイアスのない伝達を比べると、バイアスのない伝達は\\(proportion\\_of\\_trait\\_a\\)を維持し続けるのに対して、バイアスのない変異はつねに、初期頻度に\\(proportion\\_of\\_trait\\_a\\)を\\(0.5\\)に収束させた（\\(proportion\\_of\\_trait\\_a = 0.5\\)は2つの形質を想定した場合である、ということに注意する必要がある。これを形質数が\\(v\\)の場合に一般化すると、バイアスのない変異は\\(proportion\\_of\\_trait\\_a\\)を\\(1/v\\)に収束させる）。 バイアスのある変異は、文化進化においてはバイアスのない変異に比べずっと一般的であり、典型的ですらある。二者は異なるダイナミクスを示す。バイアスのある変異によって有利になった新奇の形質は特徴的な広がり方（r型の普及曲線）を呈し、その速度は突然変異率\\(mutation\\_rate\\_biased\\)によって決定される。集団サイズ\\(population\\_size\\)は\\(100\\)であろうと\\(10000\\)であろうとほぼまったく影響を及ぼさなかった。バイアスのある変異が存在する(\\(mutation\\_rate\\_biased &gt; 0\\))ならいつでも、有利な形質はたとえ開始時に全く存在しなくても、最終的に固定化にまで至る。 プログラミング上のテクニックでいえば、今回のモデルでの新しさはsample()関数で固定の確率（今回は変異率）のもとでなにかをする・しないというのを個人それぞれについて計算したことがあげられる。ループでもできないことはないのだが、我々が実装したようなベクトル化したコードはRにおいてループに比べてずっと速い。また日本語版ではrecode()関数をもちいて可読性をあげ、コード行数を減らす工夫を施している。速度は4倍程度になった8。興味のある人は原著のコードと見比べてみてほしい。 1.4 練習問題 最初のmodel_unbiased_mutation()はもう少し高速化できる。\\(A\\)と\\(B\\)がコインの裏表の関係にあることを利用してみよう。\\(A\\)をTRUE、\\(B\\)をFALSEとして扱うと、recode()による置き換えではなく、!populationとすることで形質をひっくり返すことができるようになる。recode()は他のtidyverseの関数と一貫性がなく、あまり読みやすい関数とはいえず（2021-05-26時点でLifecycleは’questioning’になっている）、実行速度もいまいちである。これを!populationというとても単純な計算で置き換えられるのは大きい（翻訳者の環境で2倍程度の速度向上）。またsum()関数も少しだけ書き換えられる。 解答例を以下に示す。 model_unbiased_mutation_truefalse &lt;- function( population_size, generations, runs, initial_proportion_of_trait_a, mutation_rate) { output &lt;- tibble( run = factor(), generation = numeric(), proportion_of_trait_a = numeric() ) for (run in 1:runs) { output_single_run &lt;- tibble( run = rep(run, generations) |&gt; as.factor(), generation = 1:generations, proportion_of_trait_a = rep(NA, generations) ) population &lt;- sample( c(TRUE, FALSE), # 変更点 population_size, replace = TRUE, prob = c(initial_proportion_of_trait_a, 1 - initial_proportion_of_trait_a) ) proportion_of_trait_a &lt;- sum(population) / population_size # 変更点 output_single_run$proportion_of_trait_a[1] &lt;- proportion_of_trait_a for (generation in 2:generations) { previous_population &lt;- population is_mutant &lt;- sample( c(TRUE, FALSE), population_size, prob = c(mutation_rate, 1 - mutation_rate), replace = TRUE ) population[is_mutant] &lt;- !population[is_mutant] # 変更点 output_single_run$proportion_of_trait_a[generation] &lt;- sum(population) / population_size # 変更点 } output &lt;- bind_rows(output, output_single_run) } output } さらに高速化を試みるなら、 proportion_of_trait_aの計算がループのたびに行われているのを、最後に一気にpopulation_sizeで割るとどうなるか（そのためにはpopulationを毎ループ保持しておく必要がある。populationをベクトルではなくtibbleとして作り直すべきだろう） is_mutantを世代のたびに計算しているが、全runs、全generationsについて一気に、つまりpopulation_sizeぶんのsample()ではなくpopulation_size \\times generations \\times runsぶんのsample()を一気に計算したらどうなるか といった検討が思い浮かぶ。もしかすると速くなるかもしれないし、遅くなるかもしれない。特に前者のアイディアは、tibbleの利用によって遅くなるぶんと、一気に計算することによって速くなるぶんを比べると、遅くなるぶんのほうが大きそうではある。また後者のアイディアは高速化には貢献しそうだが、データ構造を大きく変えなければならず、可読性も犠牲になりそうだ。このように、高速化を施すことはコードの総合的な品質としては一長一短であることが多く、一筋縄にはいかない。benchライブラリのmark()やtictocライブラリのtic(), toc()関数などを活用して、速さを測りながら高速化してみよう。 ベンチマークしながら一歩ずつ高速化するのは非常に有意義である。当初if_else()とrecode()を使った高速化を試みた(population &lt;- if_else(is_mutant, population[is_mutant] |&gt; recode(A = \"B\", B = \"A\"), population))が、むしろオリジナルよりも遅くなった。 1.5 もっと深く知りたい人に Boyd and Richerson (1985) では誘導された変異guided variationをモデリングしている。誘導された変異は本章でモデルしたバイアスのある変異に対応する。Henrich (2001) はバイアスのある変異/誘導された変異がどのように生じるかについて説明している。 原著では\\(\\mu\\)。ギリシャ文字ミュー\\(\\mu\\)は遺伝子進化において変異率をあらわす際の標準的な文字であり、ここでも類似の機能をもつ。↩︎ バイアスのあるコインを投げるからといって、これがバイアスのある変異であるわけではない。変異そのものはバイアスがないが、その生成確率じたいは50:50ではなく、むしろもっと低い(5:95など)、というだけである。↩︎ 原著ではmutateと命名されており、これ自体が変異させる関数であるかのように思わせる命令形(mutateせよ)の名前であり、あまりわかりやすいとはいえない。↩︎ 原著ではかなり違う方法を使っているが、こちらのほうがより可読性が高いのではないかと思う。ただしrecode()が遅いのか、処理速度は原著の方法を流用したほうが高い。↩︎ 原著では0.8であると明記されておらず、commonである場合としか書いていないが、この文以下の計算結果から0.8を想定していることがわかる↩︎ 原著では\\(\\mu_b\\)↩︎ 左辺（LHS）のベクトルの長さは容易に1以上になり、代入する\"A\"との長さが一致しないように思えるが、Rでは代入するものがひとつであればそれを代入先のベクトルの長さになるまで自動で繰り返してくれるrep(\"A\", length(population[is_mutant])。これをリサイクルという。↩︎ この速度の向上はrecode()関数の導入によるものではない。↩︎ "]]
